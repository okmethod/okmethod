# structure: どのようにシステムを構成するか (WIP)

**コンセプト**: 適切なインプットを揃え、ビジネスの変化に耐えうる唯一無二の個別解を導き出す

---

## 関連キーワード

- **Layered Architecture** (レイヤードアーキテクチャ)
- **Clean Architecture / Onion Architecture** (クリーンアーキテクチャ / オニオンアーキテクチャ)
- **Dependency Rule** (依存性のルール - 依存は外から内へ)
- **Package by Feature** (機能単位のパッケージング)
- **Vertical Slice Architecture** (垂直スライスアーキテクチャ - 機能ごとに層を貫通させる)
- **DTO** (Data Transfer Object - データ転送用オブジェクト)

---

## レイヤー設計の心得

**_責務を分離し、依存の方向を制御して、テスト容易性と変更容易性を高める。_**

### 依存の方向を一方向にする（Dependency Rule）

- ビジネスロジック（ドメイン層）をシステムの中心に置き、UI や DB（インフラ層）などの詳細は外側に配置する
  - 外側（詳細）から内側（抽象）への依存のみを許可する
  - 内側（ドメイン）は外側（フレームワークや DB）のことを一切知らない状態を保つ
- これにより、DB を RDBMS から NoSQL に変えたり、Web フレームワークを差し替えたりしても、ビジネスロジックへの影響を最小限に抑えられる

### 過剰な抽象化（Over-Engineering）を避ける

- 小規模なアプリケーションで厳格なクリーンアーキテクチャ（全レイヤーでの DTO 変換など）を採用すると、ボイラープレートコードが増えすぎて開発速度が落ちる
  - 単純な CRUD アプリであれば、MVC や 3 層アーキテクチャで十分な場合もある
- 「YAGNI 原則」に従い、必要になったタイミングでレイヤーを分割・抽象化する

---

## モジュール分割とディレクトリ構成の心得

**_技術的な役割ではなく、ビジネス的な意味（機能）でコードをまとめる。_**

### 機能単位でパッケージングする（Package by Feature）

- `controllers/`, `models/`, `views/` のようなレイヤー単位の分割（Package by Layer）は、機能追加の際にあちこちのフォルダを開く必要があるため避ける
- `orders/`, `users/`, `products/` のように、関連する機能（ユースケース、ドメイン、UI）を 1 箇所にまとめる（Package by Feature / Modular Monolith）
  - これにより、ある機能を削除する際、そのフォルダを消すだけで済む（凝集度が高い状態）

### コンテキストの境界を守る

- 異なるモジュール（機能）間の依存は、定義された公開インターフェース経由のみに限定する
  - 他のモジュールのデータベーステーブルを直接 JOIN したり、内部クラスを直接 import したりしない
  - これを守ることで、将来的にそのモジュールをマイクロサービスとして切り出すことが容易になる

---

## データモデル配置の心得

**_ドメインの知識をどこに置くかを明確にする。_**

### ドメインモデル貧血症を防ぐ

- エンティティ（データクラス）には、データだけでなく、そのデータを操作する振る舞い（メソッド）も実装する
  - getter/setter だけのクラスにせず、業務ルール（例: `can_cancel()`, `apply_discount()`）を持たせる
- サービス層（UseCase）が太りすぎないように、ロジックを可能な限りドメインモデルに寄せる

### データの変換（マッピング）戦略を決める

- レイヤーを跨ぐ際、データを詰め替えるか（マッピング）、そのまま通すか（共有）の方針を決める
  - 理想: 各層専用のモデル（DTO, Entity, DB Model）を用意し、変換する（結合度が低い）
  - 現実（妥協案）: シンプルなアプリなら、ドメインエンティティをそのまま UI や DB に渡すことを許容する
