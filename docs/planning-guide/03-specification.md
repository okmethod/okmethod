# specification: どのようにシステム要件を定義するか

**_システムの振る舞いを定め、システムの取りうる姿を収束させる。_**

---

## 関連キーワード

- **Functional / Non-Functional Requirements** (機能要件 / 非機能要件)
- **CRUDs** (Create, Read, Update, Delete - 基本的なデータ操作)
- **IPO** (Input-Process-Output - 入力・処理・出力)
- **BCP**（Business Continuity Plan - 事業継続計画）
- **SLA** (Service Level Agreement - サービスレベル合意)

---

## 前提条件と制約条件の整理の心得

**_プロジェクトが変えられないこと（コントロールできない外枠）を明確にする。_**

### 前提条件の継承と明文化

- 前工程で合意した内容を前提条件とする旨を明記する
  - これらの前提条件が変わる場合、前工程に立ち戻って再検討する必要がある
- 想定ユーザ、想定データを具体化する

### 制約条件を特定する

- プロジェクトの「外枠」を明確にする
  - 予算と期間: いつまでに、いくらでやる必要があるか
  - 技術的制約: 利用できるクラウドサービス、OS、言語、連携する既存システム、セキュリティガイドライン等
  - 法的制約: 個人情報保護法、業界ごとの規制
- 制約は創造性の敵ではなく、意思決定を助けるガイド or ガードレールと捉える
  - 例: 「何でも使える」状態よりも、「これしか使えない」状態の方が設計を決めやすい
- コントロールできないことに対しては、悩まない

---

## システム方式と境界設計の心得

**_システムを構成する論理コンポーネントとそれらの責任範囲を定め、システムの骨格を形成する。_**

### システム外部との境界を明確にする

- どこまでを対象システムが担い、どこからが外部システム（他サービス、連携 API）の責任となるのかを明確にする
- 外部システムとの連携方式（同期/非同期、データ形式など）と責任分界点を定める

### システムの責務を適切に分割する

- 注意: 設計工程と不可分な工程であるため、 [アーキテクチャ設計の心得](../architecting-guide/README.md) も参照のこと
- 対象システムが担う責務を洗い出し、論理コンポーネントに分割して一覧化する
  - 業務要件として定めたドメインモデルやユースケースに基づき、ひとつのコンポーネントがひとつの責務を担うようにすることが望ましい
    - 例: 「認証」「決済」「在庫管理」「顧客情報」など、独立して変更される可能性が高い単位で分離する
- システム全体の複雑度に応じて、サブシステムなどの中間層を検討する
  - 複数の論理コンポーネントをまとめてサブシステムとする
  - あるいは、サブシステムに分割してから論理コンポーネントに分割する
- 論理構成図を作成し、コンポーネント間の連携関係とデータの流れを視覚化する
  - 各コンポーネントの責務（役割）と、満たすべき外部仕様（API やインターフェースの契約）を明確にする
- 各コンポーネントの内部構造や物理構成については言及せず、後工程における設計に委ねる
  - システム要件として記載しすぎると、後工程における設計の柔軟性を損なう恐れがある

### 処理方式を決める

- 処理のタイミングを定義する
  - リアルタイム処理: 即時性が求められる処理
  - バッチ処理: 大量データ処理や即時性が不要な処理
- 同期処理、非同期処理を使い分ける
  - 同期か非同期かでアーキテクチャや I/F（画面構成等）にも大きな影響があるため、非同期にするポイントを明確にする
  - 例: ユーザーを待たせないために、重い処理（メール送信、PDF 生成など）は非同期にする
- 実行のトリガー（何が処理を開始させるのか）を定義する
  - オンデマンド: ユーザー操作や API リクエスト
  - スケジュール: 定期実行、指定日時
  - イベント: メッセージ受信、ファイルアップロード、Webhook

---

## データ要件定義の心得

**_業務要件で定義したドメイン知識を、永続化可能な論理データモデルに落とし込む。_**

### 論理データモデルを定義する

- 業務に必要なデータの実体（エンティティ、属性、関連）を定義し、論理データモデルの構造を決定する
  - 注意: 具体的なデータベースのテーブル名やインデックス、データ型などの物理データモデルの定義は、後工程の設計に委ねる
- 画面デザインが変わっても、業務上の整合性が保たれるよう、正規化のレベルを検討する

### データの質と量を定義し、見積もりできるようにする

- データ量の見積もりを行う
  - 1 単位あたりのデータサイズ、初期データ量、日次/月次の増加量、想定されるピーク時のデータ量など、仮定を置いて数値化する
    - この仮定は、前提条件と整合性を保つ必要がある
  - この見積もりは非機能要件のベースとなり、アーキテクチャ設計（DB の選定、シャーディング等）にも影響する
- データアクセス特性を定義する
  - データの整合性レベル（強い整合性、結果整合性など）や、アクセスパターン（トランザクション、検索、分析など）を明確にする
  - この特性はアーキテクチャ設計や技術選定（RDBMS が必要か、NoSQL の方が適しているか等）にも影響する

### データのライフサイクルを定義する

- データがいつ発生し（作成）、いつ変更され、いつ利用されなくなり（削除/アーカイブ）、いつ完全に消滅するのかを明確にする
- CRUDs の操作権限とタイミングを、アクターおよび機能ごとに定義する
  - 例: 「一般ユーザー」は「注文」データを作成できるが、削除はできない
- 削除ポリシーを定める (物理削除 vs. 論理削除、アーカイブの条件、保持期間)

---

## 機能要件定義の心得

**_システムの振る舞いを機能に分割し、機能が外部に提供する振る舞いとシステムの状態変化を定義する。_**

### 機能を適切に分割し、振る舞いのみを定める

- 機能要件では、「ある機能が何をするか」という振る舞い（What）を定義する
  - 内部構造や実装については言及せず、後工程における設計に委ねる
    - 例:
      - システム要件（What）: 「在庫がなければエラーメッセージを返す」
      - 設計（How）: 「在庫チェックは、分散トランザクションを避け、最終整合性を考慮した楽観ロックで行う」
    - 機能要件として記載しすぎると、後工程における設計の柔軟性を損なう恐れがある
- 業務要件で定めたユースケースやシナリオを、システムが担うべき具体的な機能（例: 注文処理、在庫検索）に分解する
  - 機能は CRUDs に分類し、各エンティティの CRUDs が網羅されているかチェックする

### 入力・処理・出力を明確にする

- 各機能について、入力・処理・出力（IPO）の仕様を定義する
  - 入力: 必要なデータ、データ形式、入力値の制約（文字数、必須項目、許容範囲など）
  - 処理: 満たすべき計算ロジックや業務ルール（例: 割引率の適用条件、在庫引き当ての優先順位）
  - 出力: 画面表示、API レスポンス、データ永続化（状態変化）の仕様
- エラー処理の振る舞いを明確にする
  - 例: 処理が失敗した場合のメッセージ、データのロールバックの有無、ログ出力の仕様など
- 検証可能性を考慮する
  - 定義された機能仕様は、結合テストやシステムテストのインプットとなる

---

## インターフェース要件定義の心得

**_システムと外部（ユーザー、他システム）との間の「契約」を定める_**

### ユーザーインターフェース（UI）要件を定義する

- 操作性（UX）の原則を定義する
  - ペルソナ（想定ユーザー）に基づき、満たすべき操作のレベル、応答性、アクセシビリティなどの原則を定める
- 必要な画面を洗い出した上で、画面遷移図を作成し各画面の関係性を表現する
  - 業務要件で定めた業務フローやユースケースに基づき、ユーザーが目的を達成するために必要な画面と導線を設計する
- ワイヤーフレーム（コンテンツ配置等の画面レイアウトを示したシンプルな線と枠による図）を活用する
  - 言葉だけの説明を避け、視覚的なすり合わせによって認識齟齬を予防し、期待値をコントロールする
  - 要件定義では情報構造と機能へのアクセス性に焦点を当て、見た目のデザインの細部（色、フォント等）は、後工程における設計に委ねる
    - システム要件として記載しすぎると、後工程における設計の柔軟性を損なう恐れがある
- 必要に応じて、画面上の項目ごとの入力制約、表示形式なども定義しておく
  - 例: 「数量」の入力制約・・・必須項目、0 以上の整数のみ、在庫数を超えないこと
  - 例: 「登録日時」の表示形式・・・ フォーマットは`YYYY/MM/DD hh:mm:ss`、タイムゾーンは JST
- 必要に応じて、ハッピーパス以外の表示も定義しておく
  - 例: データが 0 件のときの表示（Empty State）
  - 例: 読み込み中の表示（Loading State）
  - 例: エラー時の表示（Error State）

### システム間インターフェース（API）要件を定義する

- 外部システム連携の具体的な I/F の仕様（契約）を定義する
  - プロトコルとデータ形式を明確にする
    - 通信プロトコル（例: REST, gRPC, MQ）、認証方式、データの送受信形式（例: JSON, XML）等
  - 機能要件の IPO に対応する具体的な仕様を定義する
    - 例: 送信データ（リクエスト）と受信データ（レスポンス）に含まれるスキーマ（項目、データ型、必須・任意、等）、エラーコード

### インターフェースの変更管理を定義する

- インターフェースの変更管理のプロセス（バージョン管理、後方互換性の維持ポリシー、情報共有フロー）を明確にする
  - 一度定めたインターフェースの変更は、外部システムやユーザーに大きな影響を及ぼす
  - 特に、オーナーとなる組織や開発組織が異なる境界の変更管理は厳格に行うこと

---

## 非機能要件定義の心得

**_技術者でないとイメージしづらい機能以外の要求を、計測可能な品質特性として定義する_**

### 品質特性の目標値を決める

- 各種品質特性（-ility）について網羅的に検討し、要件と方針を定める
  - 性能（Performance）: ある量・ある同時実行数での処理にかかる時間に関する目標
  - 可用性（Availability）: 障害時に業務継続するための冗長化や、停止の許容度に関する目標
  - 拡張性（Scalability）: 将来的なユーザー増加・データ増加や機能追加に関する目標
  - セキュリティ（Security）: アクセス制御や、外部・内部の脅威への対策に関する目標
  - 運用性（Operability）: 監視運用・監査対応やトラブルシューティング等、システムの安定稼働のための目標
  - 保守性（Maintainability）: バージョンアップやバックアップ・リストア等、システムの安定稼働のために変更を加える際の目標
- 各品質特性の計測可能な指標を設定し、目標値を定める
  - 例: 性能・・・画面表示は 2 秒以内、API レスポンスは 500ms 以内
  - 例: 可用性・・・稼働率 99.9%（月間停止時間 43 分以内）、RTO（目標復旧時間）は 1 時間以内、外部システム停止時の振る舞い、災害時のポリシー（BCP）
  - 例: 拡張性・・・スケーリングの方針（水平スケーリング or 垂直スケーリング、オートスケールの有無）、後方互換性ポリシー
  - 例: セキュリティ・・・通信は HTTPS 必須、パスワードはハッシュ化、WAF 導入
  - 例: 運用性・・・ログの保存期間は 1 年間、監視システムへのアラート通知は 5 分以内
  - 例: 保守性・・・日次で自動バックアップ、リストアの所要時間は 1 時間以内
- 非機能要件については、追求すればするほどコストが跳ね上がることがあるので、トレードオフを踏まえて検討する

### SLA を検討する

- サービスの提供者が利用者に対して保証する品質レベル（可用性、性能、サポート対応など）を明確にする
  - 外部 API を利用する場合は、相手方の SLA を確認し、自システムの SLA 達成に支障がないか検証する
  - 保証しないものについては、保証しないことを定める
