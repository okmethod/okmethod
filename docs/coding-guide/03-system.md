# system: どのようにシステムを書くか

**_現実世界で動かしやすい実用的なシステムとして書く。_**

---

## 関連キーワード

- **Fail Fast** (フェイルファスト - 早期に失敗させる)
- **Circuit Breaker** (サーキットブレーカー - 障害の連鎖を防ぐ)
- **Idempotency** (冪等性 - 何度実行しても結果は同じ)
- **N+1 Problem** (N+1 問題 - 1 回のクエリで親データを取得後、子データを N 回のクエリで取得してしまう問題)
- **Defense in Depth** (多層防御 - セキュリティは複数層で守る)

---

## エラーハンドリングの心得

**_想定外を想像し、あらかじめ備えることで想定内にする。_**

### 想定外のエラーに陥らないように対策する

- 想定されるエラーの扱いを事前に取り決めしておき、エラーが発生した場合でも正常に終了させる（＝異常終了しないようにする）
  - 例: null/undefined チェックにより、想定外の状態を防ぐ
  - 例: try-catch で例外をキャッチし、適切なエラーメッセージを返して正常終了する
  - ただし、例外処理は乱用せず、正常処理で対応できる範囲は正常処理として書く
    - 例: 読み込むファイルが存在しない場合は例外ではなく、事前チェックで対応する
- 問題を早期に検出し、中途半端な状態のまま処理を続行したりせず、速やかに失敗させる（フェイルファスト）
  - 例: 不正な引数や null の必須パラメータを受け取ったら、処理を続けずに例外を投げる
- エラー発生時は適切なログ出力とエラー通知を行う
  - ログは内部向けのため、エラーを引き起こした詳細な状況(関連パラメータ、スタックトレース等)をログに記録し、エラーの原因を調査できるようにする
  - 外部向けのエラーメッセージは、システム内部情報を過度に露出させないように注意する
  - 重要なエラーはアラートとして外部の監視システムにも通知するため、基準や通知方法を定めておく

### ありがた迷惑なエラーハンドリングにならないようにする

- 本来対処するべきエラーを握り潰さない
  - 悪い例: `except: pass` のように、例外をキャッチしておいて無視する
- 不特定多数を対象としたエラーキャッチは避け、特定のエラーのみをキャッチする
  - 例: `except NameError:` で十分な場合に `except Exception:` を用いない
  - 特定のエラーのみをキャッチすることで、予期しないバグまで意図せず握り潰してしまうことを防ぐ
  - ただし、外部システムへのアクセスについては、意図しないエラーが起きた場合でも安全に遮断できるようにする（サーキットブレイカー）
    - この場合は、不特定多数をカバーする例外処理が必要になる

### 安全にリトライする

- ネットワークエラー等の一時的な問題で処理が中断しうる場合、リトライできるようにする
  - 例: API リクエストにタイムアウトとリトライロジックを実装する
  - ただし、一時的な問題ではない場合も考慮し、リトライ上限やエクスポネンシャルバックオフなどにより安全に遮断する（サーキットブレイカー）
- 冪等性を保つ（同じ操作を複数回実行しても結果が同じになるようにする）ことで、安全にリトライできるようにする
  - 例: 決済処理など重要な操作は、同じリクエストが 2 回届いても 2 回処理されないようにする
  - 例: API リクエストでいえば、PUT や DELETE は本質的に冪等、POST は冪等でないため注意が必要
  - 例: データベース操作でいえば、INSERT は冪等でないため、 UPSERT（存在すれば更新、なければ挿入）を使う

---

## ロギングの心得

**_いざとなった時に利用しやすいログを出力する。_**

### ログフォーマットを統一する

- 言語の標準的なロギング設定に準拠する
  - 例: Python の `logging`、Node.js の `winston`
- ログには以下の情報を含める
  - 基本フォーマット: タイムスタンプ、ログレベル、サービス名/クラス名（呼び出し元）、メッセージ
  - トレーサビリティ確保のためのコンテキスト情報: リクエスト ID、ユーザー ID
  - エラー情報: スタックトレース、エラーコード
- プレーンテキストよりも、構造化ログ（JSON など）を用いると、分析やフィルタリングが容易になる
  - 例: `{"level": "ERROR", "message": "Failed to process payment", "error_code": "E001"}`

### 適切なログレベルで出力する

- ログレベルの使い分け例
  - DEBUG: 開発時のデバッグ情報、本番環境では出力しない
  - INFO: 通常の動作情報（処理開始・終了など）
  - WARNING: 注意が必要だが、処理を続行できる
  - ERROR: ある処理が失敗した
  - CRITICAL: システムが動作不能

### センシティブな情報は出力しない

- センシティブな情報はログファイルの取り扱いを難しくするため、出力しない
  - 例: 認証情報（パスワード、トークン、秘密鍵等）、個人情報（メールアドレス、電話番号、住所等）、決済情報（クレジットカード番号等）
  - 必要に応じて、ログ出力する前にマスキング処理する
    - 例: `email: u***@example.com` のように一部を隠す

---

## パフォーマンスの心得

**_振る舞いは同じでも、スマートな方法を選ぶ。_**

### 最適なデータ構造を選択する

- 操作の時間計算量を考慮する
  - 例: 検索が多い場合は `set` や `dict`（O(1)）、順序が重要な場合は `list`
  - 例: 重複を許さない場合は `set`、キーと値のペアなら `dict`
- データアクセスパターンに合わせて選ぶ
  - 例: 頻繁にアクセスするデータはメモリ上に、大量のデータはデータベースに

### データアクセスは最小限にする

- 大量のデータを一度に取得せず、必要な分だけ取得する
  - 例: `SELECT * FROM users` のようにすべてを取得するのではなく、必要なカラムのみを指定する
  - 例: ページネーションや遅延読み込みを活用する
  - 例: `SELECT * FROM users` ではなく必要なカラムのみを指定する
- N+1 問題を避ける
  - ループ内でクエリを実行するのは避け、JOIN や一括取得（eager loading）を使う

### 計算量の最適化を心がける

- 最適なアルゴリズムを選択する
  - 例: O(n²) ではなく O(n log n) のアルゴリズムを選ぶ
- 不必要なネストループや冗長な処理を削減する
  - 例: ループ内での関数呼び出しや計算を外に出せないか検討する
  - 例: 同じ値を何度も計算しているなら、一度だけ計算して変数に保存する

### 並列処理を活用する

- 時間のかかる処理を並列化する
  - 例: 複数の API リクエストを並列実行（`asyncio`、`Promise.all` など）
- マルチスレッド・マルチプロセスを検討する
  - CPU バウンドな処理は `multiprocessing`、I/O バウンドな処理は `async/await`

### 早すぎる最適化は避ける

- まず動くコードを書き、実際に遅い部分を最適化する
  - プロファイリングツールを使ってボトルネックを特定する
    - 例: Python の `cProfile`、Node.js の `clinic`、Chrome DevTools の Performance タブ
  - 「この処理は遅いはず」という思い込みではなく、計測してから最適化する（推測するな、計測せよ）

---

## セキュリティの心得

**_攻撃者の視点で抜け道を考え、あらかじめ塞いでおく。_**

### 入力検証を必ず行う

- ユーザーから受け取るデータを信頼せず、すべての外部入力を検証する
  - 例: 型と範囲を定める（例: 年齢は 0〜150 の整数、メールアドレスは正規表現で検証）
  - 例: サイズ制限を設ける（例: ファイルアップロード、文字列の長さ）
- エスケープ処理、サニタイズを用いる
  - 例: HTML エスケープで XSS を防ぐ
  - 例: SQL プレースホルダでインジェクションを防ぐ

### 適切な認証でなりすましを防ぐ

- ユーザー認証はスクラッチで実装せず、信頼できる ID プロバイダ(IDaaS) を活用する
  - 例: Auth0、Firebase Authentication、AWS Cognito など
- セッションやトークンを適切に管理する
  - セッショントークンは推測不可能なランダム値を使う
  - トークンの有効期限を設定し、期限切れトークンを無効化する
  - HTTPS を使用してトークンの盗聴を防ぐ
- パスワードは平文やリバーシブルな暗号化は絶対に避け、必ずハッシュ化して保存する
  - 例: bcrypt、Argon2 などの安全なハッシュ関数を使う
- 多要素認証（MFA）の導入を検討する
  - セキュリティと利便性とのトレードオフを踏まえて検討する

### 適切な認可制御で権限をシンプルに扱う

- 権限(振る舞いの許可/不許可)をモデル化し、ロールとして定義する
  - 例: 管理者、一般ユーザー、ゲスト等
  - 各ロールには必要最小限の権限のみを付与する（最小権限の原則）
- リソースへのアクセスは毎回権限チェックを行う
  - 例: API エンドポイントごとに認可チェックを実施
- 多層防御を実践する
  - 例: フロントエンド、API、データベースの各層で権限チェックを行う
  - 1 つのセキュリティ層が破られても、他の層で防御できるようにする

### ライブラリを安全に利用する

- 信頼できる提供元のライブラリのみを利用する
  - 使うかどうか決める際に、ダウンロード数、メンテナンス状況、コミュニティの活発さ等を確認する
- 常に最新バージョンを利用し、脆弱性対応のパッチを適用する
  - Dependabot などの自動更新ツールを活用する

### システム内部情報を露出させない

- 外部向けのエラーメッセージには最小限の情報のみ含める
  - 例: 「ログインに失敗しました」とだけ表示し、詳細（ユーザー名の存在有無など）は返さない
- API レスポンスから内部情報を削除する
  - 例: 内部 ID や管理用フラグなどを公開しない
- 設定値（API キー、パスワード等）をハードコードしない
  - 例: 環境変数や外部設定ファイルから読み込む
  - これにより、誤って秘密情報をコミットする事故を防ぐ

---

## テストの心得

**_作ってからテストを考えるのではなく、どのようにテストするか考えながら作る。_**

### テストしやすい境界を設計する

- 外部依存を抽象化し、テスト時に差し替え可能にする
  - 例: データベースアクセスはインターフェースを介して行い、テスト時はモックを注入する
  - 例: 現在時刻を直接取得せず、時刻提供インターフェースを経由する
- 副作用を局所化し、純粋な計算ロジックを分離する
  - 例: `calculate_price(items)` と `save_to_db(price)` を分け、計算ロジックを単独でテスト可能にする
- テストケースを想定しながら、関数の責任範囲を決める
  - 例: 「この関数をテストするには何をモックすべきか？」を考え、依存が多すぎる場合は分割を検討

### 網羅的かつ見通しの良いテストケースを書く

- 1 つのテストで 1 つのことだけをテストする
  - 複数の機能を 1 つのテストに詰め込むと、テストが失敗したときに原因を特定しづらくなる
  - 良いテストは、テスト名からテストの目的と仕様が一目でわかる
    - 例: `test_user_cannot_delete_others_post()`
- テストコードの可読性を下げるノイズになるため、テストに無関係なデータは含めない
  - 例: ユーザー認証のテストなら、プロフィール情報（住所、電話番号等）は不要
- テストが失敗したとき、何が問題かすぐわかるようにする
  - 例: エラーメッセージで、期待値と実際の値を明確に示す
- ハッピーパスだけでなく、エラー処理や境界値のテストを含める
  - 例: 空配列、null、最大値/最小値などのエッジケースをテスト
  - 例: 異常系（不正な入力、ネットワークエラーなど）のテスト
- テストカバレッジは、テストケースの漏れに気づくチャンスとして活用する
  - ただし、カバレッジ 100% でも適切にバグを検出できるとは限らないため、過度な追求はしない

### テストピラミッドを意識する

- 単体テスト（Unit Tests）は最も多く書く
  - 個々の関数やメソッドの動作を検証
    - 例: `calculate_tax(100)` が正しく `10` を返すかテスト
  - 高速で実行でき、問題の特定が容易
- 結合テスト（Integration Tests）は適度に書く
  - 複数のコンポーネントが連携して動作することを検証
    - 例: API とデータベースの連携をテスト
  - ここのロジックをユニットテストであらかじめ検証しておくことで、連携部分にフォーカスすることができるようになる
- E2E テスト（End-to-End Tests）は最小限にする
  - ユーザーの操作フロー全体を検証
    - 例: ログイン → 商品追加 → 購入フローの検証
  - 実行コストが高いため、重要なシナリオのみに絞る

### テストを自動化し、継続的に実行する

- コードの変更時には必ずテストを実行する
  - 例: CI/CD パイプラインに組み込み、プルリクエスト作成時に自動テストを実行
  - テストが失敗したコードはマージせず、リグレッション（デグレード）を防ぐ
