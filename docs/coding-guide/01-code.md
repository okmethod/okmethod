# code: どのようにコードを書くか

**_個々のコード片を読みやすく書く。_**

---

## 関連キーワード

- **名は体をあらわす** (名詮自性 - 名はそのものの実体を表している。名と実は相応ずる)
- **PIE 原則** (Program Intently and Expressively - 意図を明確に記述せよ)
- **POLA** (Principle of Least Astonishment - 驚き最小の原則。読み手の予想通りに動く)
- **Magic Number** (マジックナンバー - 意味不明な数値を避ける)
- **Boy Scout Rule** (ボーイスカウトの規則 - 来た時よりも美しく)
- **Broken Windows** (割れ窓理論 - 悪いコードを放置しない)
- **Tech Debt** (技術的負債 - TODO/FIXME で明示し、計画的に解消)

---

## 命名の心得

**_命名により、その目的や内容が一目でわかる程度に明確にする。_**

**参考**: [命名チートシート](./naming-cheatsheet.md)

### 名前を短いコメントと捉え、名前に情報を詰め込む

- 抽象的で曖昧な単語よりも、具体的で明確な単語を選ぶ
  - 例: `get()` より `download()`、
  - 例: `data` より `user_data`
  - 例: `size` より `num_bytes`
- 接頭語や接尾語で情報を付加する
  - 例: `delay` より `delay_ms`（単位を明示）
  - 例: 限界値は包含/排他を明示する → `first/last`、`begin/end`、`min/max`
- 名前のフォーマットで情報を付加する
  - 例: `is_valid`、`has_error`（ブール値）
- スコープが大きな変数には長い名前をつける
  - 例: ループ内の `i` は OK だが、グローバルなら `current_user_index` にする
- 不要な単語を削除し、簡潔さを優先する
  - 例: `user_info` より `user`、`user_list` より `users`
    - 命名から型を明示的にしたい場合はその限りではない

### 一般的な期待を裏切らず、誤解されない名前をつける

- 読み手の予想通りに動くように命名する（POLA: 驚き最小の原則）
  - 例: `get_user()` という名前なのに、内部でデータを更新する（副作用がある）のは避ける
  - 例: `calculate_total()` が計算だけでなくログ出力もするのは「驚き」
- 一貫性をもたせ、類義語はきちんと使い分ける
  - 例: `create`、`generate` を混在させない
- 略語や短縮形は一般的に理解されているものを利用する
  - 例: 一時ファイル → `temp` より `tmp`
    - `temp`を利用すると温度(temperature)と理解されるおそれがある
- よくある誤解のパターン:
  - フィルター（条件に該当したものを取り出す？切り捨てる？）
  - 切り取り（指定した分を切り取る？残す？）
  - 限界値・範囲の指定（以上？超？以下？未満？）
  - ブール値（反対の意味にならない？）
- 命名のアンチパターン:
  - 可算名詞を使い、不可算名詞を避ける
    - 例: `information` より `messages`
  - 二重否定を避ける
    - 例: `disable_not_found` より `enable_found`
  - 動詞+動詞を避ける
    - 例: `stop_run` より `stop` や `pause`

### 命名規則は言語ごとの慣習に従う

- 命名規則の例
  - キャメルケース: `camelCase`
  - パスカルケース: `PascalCase`
  - スネークケース: `snake_case`
  - ケバブケース: `kebab-case`
- 可能な場合は Linter/Formatter で自動制御する

---

## コメントの心得

**_コメントにより、コードからは読み取れない意図や仕様を伝える。_**

### 書き手の意図をコメントで読み手に伝える

- コードの欠陥や仮実装を説明する（技術的負債の可視化）
  - 例: `// TODO: エッジケース（空配列）の処理が未実装`
  - 例: `// FIXME: 仮の値で実装中`
  - 技術的負債は放置せず、TODO/FIXME で明示し、計画的に解消する
- 定数の値の理由や根拠を説明する（マジックナンバーを避ける）
  - 例: `TIMEOUT = 3000  // API仕様で3秒がタイムアウト上限`
- ありそうな疑問に回答する
  - なぜこの実装が必要なのか
  - どのような仕様に基づいているのか
- 陥りやすいミスや特異な挙動について注意を促す
  - 例: `// 注意: この関数は副作用としてグローバル状態を変更する`
  - 例: `// 警告: この関数の呼び出しは重い処理なので、ループ内では使わないこと`
- 全体像やフローを補足する
  - 例: `// ユーザー認証フロー: 1. トークン検証 2. 権限チェック 3. セッション更新`
- ブロックの要約を伝える
  - 例: `// 入力データのバリデーション`

### コメントすべきでないことは書かない

- コードを見て「すぐに」わかることは書かない
  - 悪い例: `i++  // i をインクリメント`
- コメントのためのコメントをしない
  - 悪い例: 関数の引数をそのまま説明する docstring
- ひどいコードの埋め合わせに使わない
  - コメントで補足するより、コードを改善する

### 領域あたりの情報量を最大化するように書く

- 曖昧な表現や代名詞を避け、正確に書く
  - 不正確なコメントは読み手の混乱を招く
- ダラダラ書かず、簡潔に書く
  - 歯切れの悪い文章を磨く
- 実例を書く
  - 関数の入出力のコーナーケースなど
- 情報量の多い専門用語を使う
  - 例: 「データを保存」より「データをキャッシュ」「データを永続化」
  - 例: 「この処理は遅い」より「この処理の計算量は O(n²) 」
- 必要に応じて、言語固有のドキュメンテーションツールも活用する
  - Python: docstrings
  - JavaScript/TypeScript: JSDoc

---

## コードスタイルの心得

**_コーディングスタイルを統一し、読みやすく管理しやすい状態(自然で美しい状態)にする。_**

### Linter と Formatter を必ず利用する

- 言語ごとに標準的かつ一般的なものを選ぶ
  - Python: ruff, mypy
  - JavaScript/TypeScript: ESLint, Prettier
- 設定は初期状態または推奨値を利用する
- CI/CD に組み込み、自動的にチェックされる体制を推奨する
- ファイルの末尾には改行を入れる
  - 改行がない場合、加筆時に末尾自体が更新されたと認識されるなどのデメリットがある

### 一貫性のあるパターンで読み手の予測を助ける

- 似た処理は似たシルエットで書く
  - 例: エラーハンドリングは常に同じパターン（early return、try-catch など）
  - 例: 初期化処理は常に同じ順序（設定読み込み → 接続 → 検証）
- メソッドの配置順序を統一する
  - 例: public → private、重要度順、アルファベット順など
  - プロジェクト内で一貫したルールを決める
- 意味のある順序で並べる
  - 例: 定義と使用を近くに配置する
  - 例: 時系列順、重要度順など、読み手が予測できる順序
  - 無作為な順序は避ける

### 関連するコードをまとめてブロックにする

- 空行でブロックを分ける
  - 例: 変数定義、処理、返却の間に空行を入れる
- 意味的なまとまりでグループ化する
  - 例: 関連する変数宣言をまとめる
  - 例: 同じ目的の処理をまとめる
- 行数が多いコードは論理的な段落に分ける
  - 例: 50 行の関数を、準備・処理・後処理に分割

### 列を整列させて見やすくする

- 縦の線を揃えることで、コードの構造を視覚的に理解しやすくする
  - 例: 変数宣言や代入文で `=` の位置を揃える
  - 例: 似た構造のコメントを揃える
- ただし、過度な整列は避ける
  - 整列のためにコードが読みにくくなる場合は無理に揃えない
  - 自動フォーマッターの設定に従うことを優先する

### ゴミは放置せず、来た時よりも美しく

- 既存コードを修正する際は、ついでに周辺の「小さな汚れ（未使用変数、乱れたインデント）」も掃除する。（割れ窓理論、ボーイスカウトの精神）
