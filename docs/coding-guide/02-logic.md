# logic: どのように機能を書くか

**コンセプト**: 複雑な問題を、シンプルに解けるように書く

---

## 関連キーワード

- **KISS 原則** (Keep It Simple, Stupid - シンプルにしておけ)
- **DRY 原則** (Don't Repeat Yourself - 繰り返しを避けよ)
- **Rule of Three** (3 度目の法則 - 2 回までの重複は許容し、3 回目でリファクタリング)
- **YAGNI 原則** (You Aren't Gonna Need It - それはきっと必要ない)
- **SRP** (Single Responsibility Principle - 単一責任の原則。高凝集を実現)
- **SoC** (Separation of Concerns - 関心事の分離)
- **CQS** (Command-Query Separation - コマンドとクエリを分離)
- **Idempotency** (冪等性 - 同じ入力には常に同じ出力を返す)
- **Early Return** (早期リターン - ガード節で異常系を先に処理)
- **Law of Demeter** (デメテルの法則 - 直接の友達とだけ話す。低結合を実現)
- **DIP** (Dependency Inversion Principle - 依存性逆転の原則。低結合を実現)
- **DI** (Dependency Injection - 依存性の注入。具象ではなく抽象を依存させることでテストしやすくする)
- **ISP** (Interface Segregation Principle - インターフェース分離の原則。高凝集を実現)

---

## 変数とスコープの心得

変数を扱いやすくし、コードの見通しを良くする。

### 変数の数を減らす

- 一度しか使わない中間結果の一時変数を削除する
  - 例: `result = calculate(); return result` は `return calculate()` にする
- 制御フロー変数を削除する
  - 例: `done` フラグより早期リターンを使う

### 変数のスコープを縮める

- グローバル変数を避ける
  - 例: グローバルな `config` より `get_config()` で取得するか、関数の引数として渡す
- 変数の定義位置を使う場所の近くにする
  - 例: ファイル先頭で `index = 0` より、ループ直前で `for index in range(10):` のように定義する
- メソッド抽出によりスコープを縮める
  - 例: 長い関数を小さな関数に分割し、変数のスコープを関数内に閉じ込める

### 値は一度だけ書き込む

- 定数（const/final）を利用する
  - 例: 変更しない値は `const MAX_SIZE = 100` のように定数にする
  - 定数は値の理由や根拠を明示し、マジックナンバー（意味不明な数値）を避ける
- イミュータブルなデータ構造を優先する
  - 例: `list.append(item)` より `new_list = list + [item]` のように新しいリストを作成する

---

## 式と演算の心得

複雑な式を分割し、一目で理解できるようにする。

### 説明変数を使って式を分割する

- 複雑な式の結果を説明変数に代入する
  - 例: `if user.age >= 18 and user.has_license` より `is_eligible = user.age >= 18 and user.has_license; if is_eligible` の方が読みやすい
- 巨大な式は小さな部分式に分割する
  - 例: `if line.split(':')[0].strip() == 'root'` より `username = line.split(':')[0].strip(); if username == 'root'` の方が読みやすい

### 複雑な論理式を簡潔にする

- ド・モルガンの法則を活用する
  - 例: `if not (user.is_admin or user.is_owner)` より `if not user.is_admin and not user.is_owner` の方が読みやすい
- 短絡評価を活用する
  - 例: `if obj and obj.value > 0` のように書けば、obj が None の場合 obj.value を評価しない

---

## 制御フローの心得

制御フローを単純にし、読み手が立ち止まったり読み返したりしなくて済むようにする。

### 条件式の並び順を工夫する

- 左側に変化する値（変数）、右側に比較対象となる値（定数）
  - 例: `if length >= 10` は読みやすいが、`if 10 <= length` は読みにくい
- 肯定形を使う
  - 例: `if not debug` より `if debug` の方が理解しやすい
  - ただし、ガード節では否定形が自然な場合もある
    - 例: `if not user: return` のように異常系を先に処理する場合
- 単純な条件を先に書く
  - 例: `if file_exists and file_size > 0` のように、確認しやすい条件を先に配置する

### ネストを浅くする

- ガード節で異常系を先に処理する
  - 例: `if not user: return; process(user)` のように早期リターンを使う
- 条件を反転して、ネストを削減する
  - 例: `if not error:` の中に処理を書くより、`if error: return` で早期リターン
- 三項演算子は基本的に避ける
  - 例: `result = value if condition else default` は短い場合のみ許容

### ループを明確にする

- ループ変数名を工夫する
  - 例: `for u in ul:` より `for user in users:` のように意味のある名前を使う
- 無限ループには終了条件を明示する
  - 例: `while True:` を使う場合は、必ず `if condition: break` で終了条件を明示する

---

## 機能の分割と配置の心得

### 一度に 1 つのことを

- 一度に 1 つのことだけを行う関数を心がける
  - 例: データの読み込み、変換、表示を 1 つの関数で行わず、それぞれ独立させる
- 複数の責任・タスクが混在している場合は分割を検討する
  - 例: `get_user_and_send_email()` ではなく、`get_user()` と `send_email()` に分割する
  - 例: 関数名が長くなりすぎる場合は、複数の責任を持っている可能性を疑うとよい
- タスクを小さく分割する具体的な手順
  1. 関数が行っているタスクを列挙する
  2. それぞれのタスクを別の関数やクラスに分割できないか検討する
  3. 少なくとも、それぞれのタスクを別の領域に分けて整理する

### 汎用コードと特殊コードを分離する

- 汎用的なコード（ユーティリティ）と特殊なコード（ビジネスロジック）を分ける
  - 例: 文字列操作などの汎用処理は別のユーティリティ関数にする
- プロジェクト固有でないコードは別の場所に配置する
  - 例: 日付フォーマット関数は共通ライブラリに配置する
- レイヤーごとに責任を分離する（SoC）
  - 例: プレゼンテーション層、ビジネスロジック層、データアクセス層を分ける

### 読みやすさの観点でコードを整理する

- 関連する処理をまとめる
  - 例: ユーザー認証に関する処理は同じモジュールにまとめる
- 似た処理は統一する
  - 例: エラーハンドリングのパターンを統一する
- 無駄な重複を排除する（DRY 原則）
  - ただし、DRY を過度に追求するとかえってコードが複雑になる場合があるため、早すぎる抽象化は避ける（Rule of Three）

### 純粋関数を心がける

- 副作用のない関数を実装する（CQS 原則）
  - 例: グローバル変数を変更せず、引数から結果を計算して返す
  - コマンド（状態を変更する）とクエリ（値を返す）を分離する
- 同じ入力には常に同じ出力を返す（冪等性）
  - 例: `calculate_price(items)` は同じ items に対して常に同じ価格を返す
  - 冪等性により、関数のテストや並列処理が容易になる

### 関数の実践的なポリシー

- 関数は短く保つ
  - 例: 20〜30 行以内、スクロールなしで全体が見える程度（ただし、無理に分割する必要はない）
- 引数の数を制限する
  - 例: 引数が 4 つ以上なら、設定オブジェクトとしてまとめる
- 抽象化レベルを揃える
  - 例: `save_to_database()` と `user.name.split()[0]` を同じ関数内に書かない

### 関数の配置を工夫する

- 呼び出し順に配置する
  - 例: `main()` → `process_data()` → `validate()` のように上から下に読める順序
- 依存方向を一方向にする
  - 例: 上位レイヤー（UI） → 下位レイヤー（DB）の依存のみ許可し、循環依存を避ける

### 高凝集・低結合で設計する

- モジュール内の要素は密接に関連させる（高凝集）
  - 例: `UserRepository` クラスはユーザーの CRUD 操作のみを提供
  - 例: 無関係な処理（文字列処理、日付処理、ファイル I/O）を `Utils` に混在させない
  - インターフェース分離の原則（ISP）：クライアントが使わないメソッドへの依存を強制しない
- モジュール間は必要最小限のデータのみをやり取りする（低結合）
  - 例: `send_email(user_email, user_name)` のように必要なパラメータだけを受け取る
  - 例: グローバル変数での共有を避け、引数で明示的に渡す
  - 依存性逆転の原則（DIP）：具体的な実装ではなく、抽象（インターフェース）に依存する(DI パターン)
  - デメテルの法則：長いメソッドチェーンを避ける

**詳細**: [凝集度と結合度チートシート](./cohesion-coupling-cheatsheet.md)

---

## アルゴリズム選択の心得

問題を効率的に解くアルゴリズムやデータ構造を選択する。

### 適切なデータ構造を選ぶ

- 操作の時間計算量を考慮する
  - 例: 検索が多い場合は `set` や `dict`（O(1)）、順序が重要な場合は `list`
  - 例: 重複を許さない場合は `set`、キーと値のペアなら `dict`
- データアクセスは最小限にする
  - 例: `SELECT * FROM users` より必要なカラムのみを取得する
  - 例: API レスポンスから必要なフィールドのみを抽出する

### パフォーマンスクリティカルな部分を特定する

- ループの中の処理を最適化する
  - 例: ループ内での関数呼び出しや計算を外に出せないか検討する
- 不要な計算を削減する
  - 例: 同じ値を何度も計算しているなら、一度だけ計算して変数に保存する
- 早すぎる最適化は避ける（YAGNI 原則）
  - 例: まず動くコードを書き、実際に遅い部分だけを最適化する

### ライブラリを活用する

- 標準ライブラリを優先する
  - 例: 日付処理は自作せず `datetime` を使う
- 信頼性の高いライブラリを活用する
  - 例: HTTP 通信は `requests`、データ処理は `pandas` など、実績がありデファクトスタンダードなライブラリを使う

### 並列処理を活用する

- 時間のかかる処理を並列化する
  - 例: 複数の API リクエストを並列実行する（`asyncio`、`Promise.all` など）
- マルチスレッド・マルチプロセスを検討する
  - 例: CPU バウンドな処理は `multiprocessing`、I/O バウンドな処理は `threading` や `async/await`
- アーキテクチャレベルでのジョブ多重化
  - 例: メッセージキューを使ったバックグラウンドジョブの並列実行
