# logic: どのように機能を書くか

**コンセプト**: 複雑な問題を、シンプルに解けるように書く

---

## 関連キーワード

- **KISS 原則** (Keep It Simple, Stupid - シンプルにしておけ)
- **DRY 原則** (Don't Repeat Yourself - 繰り返しを避けよ)
- **YAGNI 原則** (You Aren't Gonna Need It - それはきっと必要ない)
- **SRP** (Single Responsibility Principle - 単一責任の原則)
- **SoC** (Separation of Concerns - 関心事の分離)
- **CQS** (Command-Query Separation - コマンドとクエリを分離)
- **Idempotency** (冪等性 - 同じ入力には常に同じ出力を返す)
- **Early Return** (早期リターン - ガード節で異常系を先に処理)

---

## 変数とスコープの心得

変数を扱いやすくし、コードの見通しを良くする。

### 変数の数を減らす

- 一度しか使わない中間結果の一時変数を削除する
  - 例: `result = calculate(); return result` は `return calculate()` にする
- 制御フロー変数を削除する
  - 例: `done` フラグより早期リターンを使う

### 変数のスコープを縮める

- グローバル変数を避ける
  - 例: グローバルな `config` より `get_config()` で取得するか、関数の引数として渡す
- 変数の定義位置を使う場所の近くにする
  - 例: ファイル先頭で `index = 0` より、ループ直前で `for index in range(10):` のように定義する
- メソッド抽出によりスコープを縮める
  - 例: 長い関数を小さな関数に分割し、変数のスコープを関数内に閉じ込める

### 値は一度だけ書き込む

- 定数（const/final）を利用する
  - 例: 変更しない値は `const MAX_SIZE = 100` のように定数にする
  - 定数は値の理由や根拠を明示し、マジックナンバー（意味不明な数値）を避ける
- イミュータブルなデータ構造を優先する
  - 例: `list.append(item)` より `new_list = list + [item]` のように新しいリストを作成する

---

## 式と演算の心得

複雑な式を分割し、一目で理解できるようにする。

### 説明変数を使って式を分割する

- 複雑な式の結果を説明変数に代入する
  - 例: `if user.age >= 18 and user.has_license` より `is_eligible = user.age >= 18 and user.has_license; if is_eligible` の方が読みやすい
- 巨大な式は小さな部分式に分割する
  - 例: `if line.split(':')[0].strip() == 'root'` より `username = line.split(':')[0].strip(); if username == 'root'` の方が読みやすい

### 複雑な論理式を簡潔にする

- ド・モルガンの法則を活用する
  - 例: `if not (user.is_admin or user.is_owner)` より `if not user.is_admin and not user.is_owner` の方が読みやすい
- 短絡評価を活用する
  - 例: `if obj and obj.value > 0` のように書けば、obj が None の場合 obj.value を評価しない

---

## 制御フローの心得

制御フローを単純にし、読み手が立ち止まったり読み返したりしなくて済むようにする。

### 条件式の並び順を工夫する

- 左側に変化する値（変数）、右側に比較対象となる値（定数）
  - 例: `if length >= 10` は読みやすいが、`if 10 <= length` は読みにくい
- 肯定形を使う
  - 例: `if not debug` より `if debug` の方が理解しやすい
  - ただし、ガード節では否定形が自然な場合もある
    - 例: `if not user: return` のように異常系を先に処理する場合
- 単純な条件を先に書く
  - 例: `if file_exists and file_size > 0` のように、確認しやすい条件を先に配置する

### ネストを浅くする

- ガード節で異常系を先に処理する
  - 例: `if not user: return; process(user)` のように早期リターンを使う
- 条件を反転して、ネストを削減する
  - 例: `if not error:` の中に処理を書くより、`if error: return` で早期リターン
- 三項演算子は基本的に避ける
  - 例: `result = value if condition else default` は短い場合のみ許容

### ループを明確にする

- ループ変数名を工夫する
  - 例: `for u in ul:` より `for user in users:` のように意味のある名前を使う
- 無限ループには終了条件を明示する
  - 例: `while True:` を使う場合は、必ず `if condition: break` で終了条件を明示する

---

## 機能の分割と配置の心得

### 複数の責任を持つようなら分割する

- 複数のタスクが混在している場合は分割を検討する
  - 例: `get_user_and_send_email()` ではなく、`get_user()` と `send_email()` に分割する
  - 例: 関数名が長くなりすぎる場合は、複数の責任を持っている可能性を疑うとよい

### 汎用コードと特殊コードを分離する

- 汎用的なコード（ユーティリティ）と特殊なコード（ビジネスロジック）を分ける
  - 例: 文字列操作などの汎用処理は別のユーティリティ関数にする
- プロジェクト固有でないコードは別の場所に配置する
  - 例: 日付フォーマット関数は共通ライブラリに配置する
- レイヤーごとに責任を分離する（SoC）
  - 例: プレゼンテーション層、ビジネスロジック層、データアクセス層を分ける

### 読みやすさの観点でコードを整理する

- 関連する処理をまとめる
  - 例: ユーザー認証に関する処理は同じモジュールにまとめる
- 似た処理は統一する
  - 例: エラーハンドリングのパターンを統一する
- 無駄な重複を排除する（DRY 原則）
  - 例: 同じコードが 3 回以上登場したら関数に抽出する（ただし、DRY を過度に追求しない）

### 純粋関数を心がける

- 副作用のない関数を実装する（CQS 原則）
  - 例: グローバル変数を変更せず、引数から結果を計算して返す
  - コマンド（状態を変更する）とクエリ（値を返す）を分離する
- 同じ入力には常に同じ出力を返す（冪等性）
  - 例: `calculate_price(items)` は同じ items に対して常に同じ価格を返す
  - 冪等性により、関数のテストや並列処理が容易になる

### 関数の実践的なポリシー

- 関数は短く保つ
  - 例: 20〜30 行以内、スクロールなしで全体が見える程度（ただし、無理に分割する必要はない）
- 引数の数を制限する
  - 例: 引数が 4 つ以上なら、設定オブジェクトとしてまとめる
- 抽象化レベルを揃える
  - 例: `save_to_database()` と `user.name.split()[0]` を同じ関数内に書かない

### 関数の配置を工夫する

- 呼び出し順に配置する
  - 例: `main()` → `process_data()` → `validate()` のように上から下に読める順序
- 依存方向を一方向にする
  - 例: 上位レイヤー（UI） → 下位レイヤー（DB）の依存のみ許可し、循環依存を避ける

---

## アルゴリズム選択の心得

問題を効率的に解くアルゴリズムやデータ構造を選択する。

### 適切なデータ構造を選ぶ

- 操作の時間計算量を考慮する
  - 例: 検索が多い場合は `set` や `dict`（O(1)）、順序が重要な場合は `list`
  - 例: 重複を許さない場合は `set`、キーと値のペアなら `dict`
- データアクセスは最小限にする
  - 例: `SELECT * FROM users` より必要なカラムのみを取得する
  - 例: API レスポンスから必要なフィールドのみを抽出する

### パフォーマンスクリティカルな部分を特定する

- ループの中の処理を最適化する
  - 例: ループ内での関数呼び出しや計算を外に出せないか検討する
- 不要な計算を削減する
  - 例: 同じ値を何度も計算しているなら、一度だけ計算して変数に保存する
- 早すぎる最適化は避ける（YAGNI 原則）
  - 例: まず動くコードを書き、実際に遅い部分だけを最適化する

### ライブラリを活用する

- 標準ライブラリを優先する
  - 例: 日付処理は自作せず `datetime` を使う
- 信頼性の高いライブラリを活用する
  - 例: HTTP 通信は `requests`、データ処理は `pandas` など、実績がありデファクトスタンダードなライブラリを使う

### 並列処理を活用する

- 時間のかかる処理を並列化する
  - 例: 複数の API リクエストを並列実行する（`asyncio`、`Promise.all` など）
- マルチスレッド・マルチプロセスを検討する
  - 例: CPU バウンドな処理は `multiprocessing`、I/O バウンドな処理は `threading` や `async/await`
- アーキテクチャレベルでのジョブ多重化
  - 例: メッセージキューを使ったバックグラウンドジョブの並列実行
